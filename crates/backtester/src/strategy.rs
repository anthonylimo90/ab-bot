//! Strategy trait for pluggable backtesting strategies.

use anyhow::Result;
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

use crate::data_store::MarketSnapshot;

/// Signal generated by a strategy.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signal {
    /// Unique signal identifier.
    pub id: uuid::Uuid,
    /// When the signal was generated.
    pub timestamp: DateTime<Utc>,
    /// Market to trade.
    pub market_id: String,
    /// Outcome/token to trade.
    pub outcome_id: String,
    /// Signal type.
    pub signal_type: SignalType,
    /// Target position size (as fraction of portfolio, 0.0-1.0).
    pub position_size: Decimal,
    /// Entry price target (optional).
    pub entry_price: Option<Decimal>,
    /// Stop loss price (optional).
    pub stop_loss: Option<Decimal>,
    /// Take profit price (optional).
    pub take_profit: Option<Decimal>,
    /// Signal confidence (0.0-1.0).
    pub confidence: f64,
    /// Additional metadata.
    pub metadata: HashMap<String, String>,
}

impl Signal {
    /// Create a new buy signal.
    pub fn buy(market_id: &str, outcome_id: &str, position_size: Decimal) -> Self {
        Self {
            id: uuid::Uuid::new_v4(),
            timestamp: Utc::now(),
            market_id: market_id.to_string(),
            outcome_id: outcome_id.to_string(),
            signal_type: SignalType::Buy,
            position_size,
            entry_price: None,
            stop_loss: None,
            take_profit: None,
            confidence: 1.0,
            metadata: HashMap::new(),
        }
    }

    /// Create a new sell signal.
    pub fn sell(market_id: &str, outcome_id: &str, position_size: Decimal) -> Self {
        Self {
            id: uuid::Uuid::new_v4(),
            timestamp: Utc::now(),
            market_id: market_id.to_string(),
            outcome_id: outcome_id.to_string(),
            signal_type: SignalType::Sell,
            position_size,
            entry_price: None,
            stop_loss: None,
            take_profit: None,
            confidence: 1.0,
            metadata: HashMap::new(),
        }
    }

    /// Create a close position signal.
    pub fn close(market_id: &str, outcome_id: &str) -> Self {
        Self {
            id: uuid::Uuid::new_v4(),
            timestamp: Utc::now(),
            market_id: market_id.to_string(),
            outcome_id: outcome_id.to_string(),
            signal_type: SignalType::Close,
            position_size: Decimal::ZERO,
            entry_price: None,
            stop_loss: None,
            take_profit: None,
            confidence: 1.0,
            metadata: HashMap::new(),
        }
    }

    /// Set entry price.
    pub fn with_entry_price(mut self, price: Decimal) -> Self {
        self.entry_price = Some(price);
        self
    }

    /// Set stop loss.
    pub fn with_stop_loss(mut self, price: Decimal) -> Self {
        self.stop_loss = Some(price);
        self
    }

    /// Set take profit.
    pub fn with_take_profit(mut self, price: Decimal) -> Self {
        self.take_profit = Some(price);
        self
    }

    /// Set confidence level.
    pub fn with_confidence(mut self, confidence: f64) -> Self {
        self.confidence = confidence.clamp(0.0, 1.0);
        self
    }

    /// Add metadata.
    pub fn with_metadata(mut self, key: &str, value: &str) -> Self {
        self.metadata.insert(key.to_string(), value.to_string());
        self
    }
}

/// Type of trading signal.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum SignalType {
    /// Open or add to long position.
    Buy,
    /// Close or reduce long position.
    Sell,
    /// Close entire position.
    Close,
    /// No action.
    Hold,
}

/// Current state passed to strategies.
#[derive(Debug, Clone)]
pub struct StrategyContext {
    /// Current timestamp in simulation.
    pub timestamp: DateTime<Utc>,
    /// Current portfolio value.
    pub portfolio_value: Decimal,
    /// Available cash.
    pub available_cash: Decimal,
    /// Current positions.
    pub positions: HashMap<String, Position>,
    /// Recent market snapshots (keyed by market_id).
    pub market_data: HashMap<String, Vec<MarketSnapshot>>,
    /// Strategy-specific state storage.
    pub state: HashMap<String, String>,
}

impl StrategyContext {
    /// Create a new strategy context.
    pub fn new(portfolio_value: Decimal) -> Self {
        Self {
            timestamp: Utc::now(),
            portfolio_value,
            available_cash: portfolio_value,
            positions: HashMap::new(),
            market_data: HashMap::new(),
            state: HashMap::new(),
        }
    }

    /// Get position for a market.
    pub fn get_position(&self, market_id: &str) -> Option<&Position> {
        self.positions.get(market_id)
    }

    /// Check if we have a position in a market.
    pub fn has_position(&self, market_id: &str) -> bool {
        self.positions.contains_key(market_id)
    }

    /// Get latest snapshot for a market.
    pub fn latest_snapshot(&self, market_id: &str) -> Option<&MarketSnapshot> {
        self.market_data.get(market_id)?.last()
    }

    /// Get N most recent snapshots for a market.
    pub fn recent_snapshots(&self, market_id: &str, n: usize) -> Vec<&MarketSnapshot> {
        self.market_data
            .get(market_id)
            .map(|snapshots| {
                let start = snapshots.len().saturating_sub(n);
                snapshots[start..].iter().collect()
            })
            .unwrap_or_default()
    }

    /// Store strategy state.
    pub fn set_state(&mut self, key: &str, value: &str) {
        self.state.insert(key.to_string(), value.to_string());
    }

    /// Get strategy state.
    pub fn get_state(&self, key: &str) -> Option<&str> {
        self.state.get(key).map(|s| s.as_str())
    }
}

/// Position held during backtest.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Position {
    /// Market identifier.
    pub market_id: String,
    /// Outcome/token identifier.
    pub outcome_id: String,
    /// Number of shares held.
    pub quantity: Decimal,
    /// Average entry price.
    pub entry_price: Decimal,
    /// When position was opened.
    pub opened_at: DateTime<Utc>,
    /// Current unrealized P&L.
    pub unrealized_pnl: Decimal,
    /// Current market price.
    pub current_price: Decimal,
}

impl Position {
    /// Calculate position value.
    pub fn value(&self) -> Decimal {
        self.quantity * self.current_price
    }

    /// Calculate return percentage.
    pub fn return_pct(&self) -> Decimal {
        if self.entry_price == Decimal::ZERO {
            Decimal::ZERO
        } else {
            (self.current_price - self.entry_price) / self.entry_price
        }
    }
}

/// Trait for implementing backtesting strategies.
#[async_trait]
pub trait Strategy: Send + Sync {
    /// Strategy name for identification.
    fn name(&self) -> &str;

    /// Strategy description.
    fn description(&self) -> &str {
        ""
    }

    /// Initialize the strategy (called once before backtest starts).
    async fn initialize(&mut self, _context: &StrategyContext) -> Result<()> {
        Ok(())
    }

    /// Generate signals based on current market state.
    /// Called for each time step in the backtest.
    async fn on_data(&mut self, context: &StrategyContext) -> Result<Vec<Signal>>;

    /// Called when an order is filled.
    async fn on_fill(&mut self, _signal: &Signal, _fill_price: Decimal, _quantity: Decimal) -> Result<()> {
        Ok(())
    }

    /// Called at the end of the backtest.
    async fn finalize(&mut self, _context: &StrategyContext) -> Result<()> {
        Ok(())
    }

    /// Get strategy parameters for logging/analysis.
    fn parameters(&self) -> HashMap<String, String> {
        HashMap::new()
    }
}

/// Simple arbitrage strategy for backtesting.
pub struct ArbitrageStrategy {
    /// Minimum spread to trigger entry.
    pub min_spread: Decimal,
    /// Position size as fraction of portfolio.
    pub position_size: Decimal,
    /// Maximum positions to hold.
    pub max_positions: usize,
}

impl Default for ArbitrageStrategy {
    fn default() -> Self {
        Self {
            min_spread: Decimal::new(2, 2), // 2%
            position_size: Decimal::new(10, 2), // 10%
            max_positions: 5,
        }
    }
}

impl ArbitrageStrategy {
    pub fn new(min_spread: Decimal, position_size: Decimal, max_positions: usize) -> Self {
        Self {
            min_spread,
            position_size,
            max_positions,
        }
    }
}

#[async_trait]
impl Strategy for ArbitrageStrategy {
    fn name(&self) -> &str {
        "Arbitrage"
    }

    fn description(&self) -> &str {
        "Detects and trades price discrepancies between yes/no outcomes"
    }

    async fn on_data(&mut self, context: &StrategyContext) -> Result<Vec<Signal>> {
        let mut signals = Vec::new();

        // Skip if at max positions
        if context.positions.len() >= self.max_positions {
            return Ok(signals);
        }

        for (market_id, snapshots) in &context.market_data {
            if let Some(snapshot) = snapshots.last() {
                // Check for arbitrage opportunity
                let total_ask = snapshot.yes_ask + snapshot.no_ask;
                let spread = Decimal::ONE - total_ask;

                if spread >= self.min_spread && !context.has_position(market_id) {
                    // Buy the cheaper side
                    let (outcome, price) = if snapshot.yes_ask < snapshot.no_ask {
                        ("yes", snapshot.yes_ask)
                    } else {
                        ("no", snapshot.no_ask)
                    };

                    let signal = Signal::buy(market_id, outcome, self.position_size)
                        .with_entry_price(price)
                        .with_confidence(spread.to_string().parse().unwrap_or(0.5))
                        .with_metadata("spread", &spread.to_string());

                    signals.push(signal);
                }
            }
        }

        Ok(signals)
    }

    fn parameters(&self) -> HashMap<String, String> {
        let mut params = HashMap::new();
        params.insert("min_spread".to_string(), self.min_spread.to_string());
        params.insert("position_size".to_string(), self.position_size.to_string());
        params.insert("max_positions".to_string(), self.max_positions.to_string());
        params
    }
}

/// Momentum-based strategy.
pub struct MomentumStrategy {
    /// Lookback period for momentum calculation.
    pub lookback_periods: usize,
    /// Minimum momentum threshold to trigger entry.
    pub momentum_threshold: Decimal,
    /// Position size as fraction of portfolio.
    pub position_size: Decimal,
}

impl Default for MomentumStrategy {
    fn default() -> Self {
        Self {
            lookback_periods: 10,
            momentum_threshold: Decimal::new(5, 2), // 5%
            position_size: Decimal::new(10, 2), // 10%
        }
    }
}

#[async_trait]
impl Strategy for MomentumStrategy {
    fn name(&self) -> &str {
        "Momentum"
    }

    fn description(&self) -> &str {
        "Follows price momentum with configurable lookback"
    }

    async fn on_data(&mut self, context: &StrategyContext) -> Result<Vec<Signal>> {
        let mut signals = Vec::new();

        for (market_id, snapshots) in &context.market_data {
            if snapshots.len() < self.lookback_periods {
                continue;
            }

            let recent = context.recent_snapshots(market_id, self.lookback_periods);
            if recent.len() < 2 {
                continue;
            }

            let first_price = recent.first().map(|s| s.yes_bid).unwrap_or(Decimal::ZERO);
            let last_price = recent.last().map(|s| s.yes_bid).unwrap_or(Decimal::ZERO);

            if first_price == Decimal::ZERO {
                continue;
            }

            let momentum = (last_price - first_price) / first_price;

            if momentum > self.momentum_threshold && !context.has_position(market_id) {
                // Positive momentum - buy
                signals.push(
                    Signal::buy(market_id, "yes", self.position_size)
                        .with_metadata("momentum", &momentum.to_string()),
                );
            } else if momentum < -self.momentum_threshold && context.has_position(market_id) {
                // Negative momentum - close position
                signals.push(Signal::close(market_id, "yes"));
            }
        }

        Ok(signals)
    }

    fn parameters(&self) -> HashMap<String, String> {
        let mut params = HashMap::new();
        params.insert("lookback_periods".to_string(), self.lookback_periods.to_string());
        params.insert("momentum_threshold".to_string(), self.momentum_threshold.to_string());
        params.insert("position_size".to_string(), self.position_size.to_string());
        params
    }
}

/// Mean reversion strategy.
pub struct MeanReversionStrategy {
    /// Lookback period for mean calculation.
    pub lookback_periods: usize,
    /// Number of standard deviations for entry.
    pub entry_std_devs: f64,
    /// Position size as fraction of portfolio.
    pub position_size: Decimal,
}

impl Default for MeanReversionStrategy {
    fn default() -> Self {
        Self {
            lookback_periods: 20,
            entry_std_devs: 2.0,
            position_size: Decimal::new(10, 2),
        }
    }
}

#[async_trait]
impl Strategy for MeanReversionStrategy {
    fn name(&self) -> &str {
        "MeanReversion"
    }

    fn description(&self) -> &str {
        "Trades deviations from moving average"
    }

    async fn on_data(&mut self, context: &StrategyContext) -> Result<Vec<Signal>> {
        let mut signals = Vec::new();

        for (market_id, snapshots) in &context.market_data {
            if snapshots.len() < self.lookback_periods {
                continue;
            }

            let recent = context.recent_snapshots(market_id, self.lookback_periods);
            let prices: Vec<f64> = recent
                .iter()
                .filter_map(|s| s.yes_bid.to_string().parse().ok())
                .collect();

            if prices.len() < self.lookback_periods {
                continue;
            }

            let mean: f64 = prices.iter().sum::<f64>() / prices.len() as f64;
            let variance: f64 = prices.iter().map(|p| (p - mean).powi(2)).sum::<f64>() / prices.len() as f64;
            let std_dev = variance.sqrt();

            let current_price: f64 = prices.last().copied().unwrap_or(0.0);
            let z_score = if std_dev > 0.0 {
                (current_price - mean) / std_dev
            } else {
                0.0
            };

            if z_score < -self.entry_std_devs && !context.has_position(market_id) {
                // Price below mean - buy expecting reversion
                signals.push(
                    Signal::buy(market_id, "yes", self.position_size)
                        .with_metadata("z_score", &z_score.to_string()),
                );
            } else if z_score > self.entry_std_devs && context.has_position(market_id) {
                // Price above mean - close position
                signals.push(Signal::close(market_id, "yes"));
            }
        }

        Ok(signals)
    }

    fn parameters(&self) -> HashMap<String, String> {
        let mut params = HashMap::new();
        params.insert("lookback_periods".to_string(), self.lookback_periods.to_string());
        params.insert("entry_std_devs".to_string(), self.entry_std_devs.to_string());
        params.insert("position_size".to_string(), self.position_size.to_string());
        params
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_signal_creation() {
        let signal = Signal::buy("market1", "yes", Decimal::new(10, 2))
            .with_entry_price(Decimal::new(50, 2))
            .with_stop_loss(Decimal::new(45, 2))
            .with_confidence(0.8);

        assert_eq!(signal.market_id, "market1");
        assert_eq!(signal.outcome_id, "yes");
        assert_eq!(signal.signal_type, SignalType::Buy);
        assert_eq!(signal.entry_price, Some(Decimal::new(50, 2)));
        assert_eq!(signal.stop_loss, Some(Decimal::new(45, 2)));
        assert_eq!(signal.confidence, 0.8);
    }

    #[test]
    fn test_position_calculations() {
        let position = Position {
            market_id: "market1".to_string(),
            outcome_id: "yes".to_string(),
            quantity: Decimal::new(100, 0),
            entry_price: Decimal::new(50, 2),
            opened_at: Utc::now(),
            unrealized_pnl: Decimal::new(10, 0),
            current_price: Decimal::new(60, 2),
        };

        assert_eq!(position.value(), Decimal::new(60, 0));
        assert_eq!(position.return_pct(), Decimal::new(20, 2)); // 20%
    }

    #[test]
    fn test_strategy_context() {
        let mut context = StrategyContext::new(Decimal::new(10000, 0));
        context.set_state("test_key", "test_value");

        assert_eq!(context.get_state("test_key"), Some("test_value"));
        assert!(!context.has_position("market1"));
    }

    #[tokio::test]
    async fn test_arbitrage_strategy() {
        let mut strategy = ArbitrageStrategy::default();
        let context = StrategyContext::new(Decimal::new(10000, 0));

        let result = strategy.on_data(&context).await;
        assert!(result.is_ok());
        assert!(result.unwrap().is_empty()); // No market data, no signals
    }

    #[test]
    fn test_strategy_parameters() {
        let strategy = ArbitrageStrategy::new(
            Decimal::new(3, 2),
            Decimal::new(15, 2),
            10,
        );

        let params = strategy.parameters();
        assert_eq!(params.get("min_spread"), Some(&"0.03".to_string()));
        assert_eq!(params.get("position_size"), Some(&"0.15".to_string()));
        assert_eq!(params.get("max_positions"), Some(&"10".to_string()));
    }
}
